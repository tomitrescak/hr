// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum Role {
  USER
  PROJECT_MANAGER
}

enum CompetencyType {
  KNOWLEDGE
  SKILL
  TECH_TOOL
  ABILITY
  VALUE
  BEHAVIOUR
  ENABLER
}

enum Proficiency {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  EXPERT
}

enum LeanState {
  BACKLOG
  READY
  IN_PROGRESS
  BLOCKED
  REVIEW
  DONE
}



enum Contribution {
  LOW
  MEDIUM
  HIGH
}

enum ChangeState {
  CREATED
  MODIFIED
}


enum EntityKind {
  PERSON
  COURSE
  PROJECT
  TASK
  PERSON_COMPETENCY
  COURSE_COMPETENCY
  PROJECT_ALLOCATION
  OKR
  KEY_RESULT
}

enum Priority {
  LOW
  MEDIUM
  HIGH
}

enum CourseType {
  COURSE
  SPECIALISATION
}

enum ProjectStatus {
  ACTIVE
  COMPLETED
  ON_HOLD
  PLANNING
}

// Models
model User {
  id           String @id @default(uuid())
  email        String @unique
  passwordHash String
  name         String
  role         Role   @default(USER)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  person Person?
  changeLogs         ChangeLog[]

  @@map("users")
}

model Person {
  id               String   @id @default(uuid())
  userId           String   @unique
  name             String
  email            String   @unique
  alternativeEmail String?
  role             Role
  entryDate        DateTime @default(now())
  isActive         Boolean  @default(true)
  deactivatedAt    DateTime?
  cv               String?  // CV content for competency extraction
  capacity         Int      @default(100) // Person's capacity percentage (0-100)

  // Relations
  user                User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  competencies        PersonCompetency[]
  oneOnOneReviews     PersonReview[]      @relation("PersonOneOnOneReviews")
  taskAssignments     Task[]
  projectAllocations  ProjectAllocation[]
  courseEnrollments   CourseEnrollment[]

  @@map("people")
}

model Competency {
  id          String         @id @default(uuid())
  type        CompetencyType
  name        String
  description String?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  // Relations
  personCompetencies PersonCompetency[]
  courseCompetencies CourseCompetency[]

  @@map("competencies")
}

model PersonCompetency {
  id            String       @id @default(uuid())
  personId      String
  competencyId  String
  proficiency   Proficiency?
  lastUpdatedAt DateTime     @default(now())

  // Relations
  person     Person     @relation(fields: [personId], references: [id], onDelete: Cascade)
  competency Competency @relation(fields: [competencyId], references: [id], onDelete: Cascade)

  @@unique([personId, competencyId])
  @@map("person_competencies")
}

model Course {
  id             String        @id @default(uuid())
  name           String
  description    String?
  content        String?
  url            String?       // External URL for the course
  type           CourseType    @default(COURSE)
  duration       Int?          // Duration in hours
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  // Relations
  competencies CourseCompetency[]
  enrollments  CourseEnrollment[]
  
  // Specialisation relations
  specialisationCourses SpecialisationCourse[] @relation("SpecialisationToSpecialisationCourse")
  courseSpecialisations SpecialisationCourse[] @relation("CourseToSpecialisationCourse")

  @@map("courses")
}

model CourseCompetency {
  id           String       @id @default(uuid())
  courseId     String
  competencyId String
  proficiency  Proficiency?

  // Relations
  course     Course     @relation(fields: [courseId], references: [id], onDelete: Cascade)
  competency Competency @relation(fields: [competencyId], references: [id], onDelete: Cascade)

  @@unique([courseId, competencyId])
  @@map("course_competencies")
}

model SpecialisationCourse {
  id               String @id @default(uuid())
  specialisationId String
  courseId         String
  order            Int?   // Optional ordering for courses within specialisation
  createdAt        DateTime @default(now())

  // Relations
  specialisation Course @relation("SpecialisationToSpecialisationCourse", fields: [specialisationId], references: [id], onDelete: Cascade)
  course         Course @relation("CourseToSpecialisationCourse", fields: [courseId], references: [id], onDelete: Cascade)

  @@unique([specialisationId, courseId])
  @@map("specialisation_courses")
}

enum EnrollmentStatus {
  WISHLIST
  IN_PROGRESS
  COMPLETED
}

model CourseEnrollment {
  id          String           @id @default(uuid())
  courseId    String
  personId    String
  status      EnrollmentStatus @default(WISHLIST)
  progress    Int?             @default(0) // 0-100
  completed   Boolean          @default(false)
  enrolledAt  DateTime         @default(now())
  startedAt   DateTime?
  completedAt DateTime?

  // Relations
  course Course @relation(fields: [courseId], references: [id], onDelete: Cascade)
  person Person @relation(fields: [personId], references: [id], onDelete: Cascade)

  @@unique([courseId, personId])
  @@map("course_enrollments")
}

model Project {
  id          String        @id @default(uuid())
  name        String
  description String
  status      ProjectStatus @default(ACTIVE)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  // Relations
  okrs         OKR[]
  allocations  ProjectAllocation[]
  tasks        Task[]

  @@map("projects")
}

model OKR {
  id          String    @id @default(uuid())
  projectId   String
  title       String
  description String
  metric      String?
  target      String?
  dueDate     DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  project    Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)
  keyResults KeyResult[]
  tasks      Task[]

  @@map("okrs")
}

model KeyResult {
  id          String    @id @default(uuid())
  okrId       String
  title       String
  description String?
  progress    Int       @default(0) // 0-100 percentage (replaces completion)
  target      String?
  metric      String?
  dueDate     DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  okr OKR @relation(fields: [okrId], references: [id], onDelete: Cascade)

  @@map("key_results")
}

model ProjectAllocation {
  id                 String  @id @default(uuid())
  projectId          String
  personId           String?
  title              String
  description        String
  capacityAllocation Int     @default(0) // Percentage of person's capacity allocated (0-100)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // Relations
  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  person  Person? @relation(fields: [personId], references: [id], onDelete: SetNull)

  @@map("project_allocations")
}

model Task {
  id          String     @id @default(uuid())
  projectId   String
  okrId       String?    // Optional assignment to OKR
  title       String
  description String?
  assigneeId  String?
  priority    Priority?  @default(MEDIUM)
  state       LeanState  @default(BACKLOG)
  dueDate     DateTime?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  // Relations
  project  Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  okr      OKR?    @relation(fields: [okrId], references: [id], onDelete: SetNull)
  assignee Person? @relation(fields: [assigneeId], references: [id], onDelete: SetNull)

  @@map("tasks")
}




model PersonReview {
  id            String   @id @default(uuid())
  personId      String
  recordingText String   // Transcribed text from recording
  notes         String   // Final processed notes
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  person Person @relation("PersonOneOnOneReviews", fields: [personId], references: [id], onDelete: Cascade)

  @@map("person_reviews")
}

model ChangeLog {
  id         String      @id @default(uuid())
  entity     EntityKind
  entityId   String
  field      String
  fromValue  Json?
  toValue    Json?
  state      ChangeState
  changedAt  DateTime    @default(now())
  changedById String

  // Relations
  changedBy User @relation(fields: [changedById], references: [id])

  @@index([entity, entityId])
  @@index([changedAt])
  @@map("change_logs")
}
